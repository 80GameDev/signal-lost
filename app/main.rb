# ================================================================
# 文件路径：app/main.rb
# 项目名称：《Signal Lost / 孤波》
#
# 阶段说明：
#   Day 1–3 主要目标是建立最基本的“场景管理系统（SceneManager）”
#   并接入启动场景（BootScene），实现游戏循环的最小可运行单元。
#
# DragonRuby 框架机制简介：
#   - DragonRuby 游戏的主循环函数必须命名为 tick(args)
#   - 每一帧都会自动调用 tick，并传入 args（全局上下文）
#   - 我们通常把游戏逻辑组织为多个“场景”（Scene），
#     每个场景负责自己的初始化、输入处理、状态更新、渲染。
#
# 本文件职责：
#   - 引入 BootScene（启动场景）
#   - 定义 SceneManager（场景管理器）
#   - 提供 tick(args) 全局入口，驱动整个游戏逻辑
# ================================================================

# ---------------------------------------------------------------
# 一、引入启动场景类
# ---------------------------------------------------------------
# $gtk.require 是 DragonRuby 的专用加载方法，
# 类似 Ruby 的 require，但支持热加载（Hot Reload）。
# 当文件被修改后，游戏引擎会自动重新加载它。
$gtk.require "app/scenes/boot_scene.rb"

# ---------------------------------------------------------------
# 二、场景管理器（SceneManager）
# ---------------------------------------------------------------
# 用于在多个游戏场景之间切换。
# 当前版本只包含一个 BootScene（启动场景），
# 未来可扩展为菜单场景、无线电调谐场景、剧情场景等。
class SceneManager
  def initialize
    # 初始化时加载启动场景
    # 将当前场景设置为 BootScene 实例
    @current_scene = BootScene.new
  end

  # 每帧更新
  # 该方法会被全局 tick(args) 调用，
  # 其作用是将游戏循环的控制权交给当前场景对象。
  def tick(args)
    @current_scene.tick(args)
  end
end

# ---------------------------------------------------------------
# 三、全局 tick(args)
# ---------------------------------------------------------------
# DragonRuby 主循环入口函数（类似 Unity 的 Update 或 Godot 的 _process）
# 每一帧都会被引擎自动调用。
def tick(args)
  # 初始化全局的场景管理器
  # args.state 是全局状态存储区（整个游戏生命周期内保持）
  args.state.scene_manager ||= SceneManager.new

  # 把本帧逻辑交给场景管理器，
  # 再由场景管理器调用当前场景的 tick(args)。
  args.state.scene_manager.tick(args)
end
